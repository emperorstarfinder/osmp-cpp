// Copyright Hugh Perkins 2004
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURVector3E. See the GNU General Public License for
//  more details.
//
// You should have received a copy of the GNU General Public License along
// with this program in the file licence.txt; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-
// 1307 USA
// You can find the licence also on the web at:
// http://www.opensource.org/licenses/gpl-license.php
//

//! \file
//! \brief mvworldstorage is the class used to store the world associated with one server

//! mvworldstorage is the class used to store the world associated with one server
//! including all the objects in it and the avatars (which are just objects)
//! mvworldstorage is a container for objects of type Object and their derivatives, such as Prims and Cubes
//! mvworldstorage contains functions for managing the objects in the world: creating, modifying, deleting.
//! It is capable of taking XML documents as input for object creation/update
//!
//! the mvWorldStorage class does the following:
//! - contains an array of ObjectS, which is basically eveyting in the sim, including avatars, but not
//! including hte current (temporary) hardcoded platform
//! - contains functions for managing these objects:
//!    - adding them
//!    - updating them
//!     - deleting them
//!    - unlinking them
//!
//! This is a common class used by metaverseserver, rendererglutsplit, and the scirpting engines
//!
//! Note that there are two ways of identifying an object:
//! - the global and unique iReference value generated by the database; this is fixed fo rht life of an object
//! - the position in the p_Objects array (iArrayNum).  IMPORTANT: this can change throughout the life of an object
//! Current best method to access an object is via its iReference by calling GetObjectByReference(iReference) and checking
//! result is not NULL
//!

#ifndef _MVWORLDSTORAGE_H
#define _MVWORLDSTORAGE_H

#ifndef TIXML_USE_STL
#define TIXML_USE_STL
#endif

#ifdef _WIN32
#include <windows.h>
#endif

//#include <GL/gl.h>
//#include <GL/glu.h>
//#include <GL/glut.h>

#include <cstdlib>
#include <iostream>
#include <string.h>
#include <math.h>
#include <stdio.h>
using namespace std;

#include "Object.h"
#include "ObjectGrouping.h"

//! mvworldstorage is the class used to store the world associated with one server

//! mvworldstorage is the class used to store the world associated with one server
//! including all the objects in it and the avatars (which are just objects)
//! mvworldstorage is a container for objects of type Object and their derivatives, such as Prims and Cubes
//! mvworldstorage contains functions for managing the objects in the world: creating, modifying, deleting.
//! It is capable of taking XML documents as input for object creation/update
//!
//! the mvWorldStorage class does the following:
//! - contains an array of ObjectS, which is basically eveyting in the sim, including avatars, but not
//! including hte current (temporary) hardcoded platform
//! - contains functions for managing these objects:
//!    - adding them
//!    - updating them
//!     - deleting them
//!    - unlinking them
//!
//! This is a common class used by metaverseserver, rendererglutsplit, and the scirpting engines
//!
//! Note that there are two ways of identifying an object:
//! - the global and unique iReference value generated by the database; this is fixed fo rht life of an object
//! - the position in the p_Objects array (iArrayNum).  IMPORTANT: this can change throughout the life of an object
//! Current best method to access an object is via its iReference by calling GetObjectByReference(iReference) and checking
//! result is not NULL
//!
class mvWorldStorage
{
public:
   int iNumObjects;  //!< number of objects in world
   char skyboxChecksum[33];  //!< reference id (md5 checksum) of skybox

   mvWorldStorage();

   int GetArrayNumForObjectReference( int iReference );             //!< iReference is the unique reference number assigned by the db
                                                                    //!< iArrayNum is the sequence number within the p_Objects array
                                                                    //!< this function converts from reference number to iArrayNum
   inline Object *GetObject( int iArrayNum ){ return p_Objects[ iArrayNum ]; }                //!< returns a pointer to the object at position iArrayNum
                                                      //!< returns -1 if not found. MAKE SURE TO CHECK AGAINST -1 before using it
   Object *GetObjectByReference( int iReference );    //!< returns a pointer to object with specified refrence, or NULL if not found
   inline static const int GetMaxObjects()
   {
      return iMaxObjects;
   }

   //! Deletes the object specified by iReference

   //! Deletes the object specified by iReference
   //! bRecursive deletes children if the object is an objectgrouping, otherwise the children will remain (but unlinked)
   //! bForceDeleteIfLastPrim is used to overcome a sanity check during deletes
   void DeleteObjectByObjectReference( int iReference, bool bRecursive = false, bool bForceDeleteIfLastPrim = false );

   //! Unlinks p_Object from parent object (if in objectgrouping)
   void DereferenceParent( Object *p_Object );

   //! Finds parent of parent of parent of iObjectReference
   int GetTopLevelParentReference( int iObjectReference );


   void DeleteObjectXML( TiXmlElement *pElement );                        //!< delete an object identified by the passed-in XML
   Object *StoreObjectXMLString( const char *XMLString );
   Object *StoreObjectXML( TiXmlElement *pElement );
   Object *UpdateObjectXMLString( const char *XMLString );                        //!< Update is something permanent and fairly static
   Object *UpdateObjectXML( TiXmlElement *pElement );                        //!< Update is something permanent and fairly static
   void MoveObjectXML( TiXmlElement *pElement );                          //!< Move is something dynamic, such as a vehicle or merrygoround
                                                                      //!< Moves are interpolated over a timeframe, updates happen straightaway
   void Clear();  //!< hard reset...  (used in hyperlinking for example)

   //! Checks if iGroupReference is empty (has no child prims)
   bool IsLastPrimInGroup( int iGroupReference );

   char *mvWorldStorage::GetSkyboxChecksum();
	void mvWorldStorage::SetSkyboxChecksum( const char *sNewChecksum );

   int AddObject( Object *p_Object );                 //!< adds an object.  eg iArrayNum = World.AddObject( new Cube );
   void DeleteObject( int iArrayNum );   //!< Deletes object specified by iArrayNum (reference number within p_Objects)

protected:
   static const int iMaxObjects = 1000;  //<! maximum number of objects we can hold in world
   Object *p_Objects[iMaxObjects];  //!< All the objects in the world

   void UnlinkChildren( ObjectGrouping *p_Group );  //!< Unlinks children of p_Group
   void LinkFromXML( ObjectGrouping *p_Group, TiXmlElement *pElement );

   void CrossReferenceParentIfNecessary( int SubObjectArrayPos );     //!< when a new object arrives with iParentReference set (non-zero),
                                                                      //!< this function will handle searching for its parent ObjectGrouping
                                                                      //!< and linking the two
   void CrossReferenceChildrenIfNecessary( ObjectGrouping *p_ObjectGrouping );     //!< like CrossReferenceParentIfNecessary, but call this when
                                                                      //!< and ObjectGrouping arrives

};

#endif // _MVWORLDSTORAGE_H
